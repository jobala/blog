---
title: "Scheduling"
date: 2024-11-02T09:37:52+03:00
draft: true
---

In `kernel/main.c` we see that once xv6 has booted, it sets up a process table with a call to procinit.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/main.c#L22-L21" >}}

It is necessary to setup the process table before calling `scheduler` because the `scheduler` needs a process table from which it can select a
process to give CPU time to.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/proc.c#L46-L59" >}}

In `procinit` we initialize an array with 64 elements, this array is our process table and by definition it contains a
maximum of 64 processes. We then acquire pid and wait locks, which I am not sure why we do that because at this point we
are still running on a single core and there's no scheduling yet, anyway, the pid lock ensures that the pid are assigned
consistently and I am not sure what the wait lock does. The process state is then set to `UNUSED` and we initilize the
process kernel stack `kstack`.

And calls the `scheduler` function to start running the scheduler. Note
that the process table is only setup by the booting core and the schedule function is executed by all cores.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/main.c#L44-L43" >}}

When each CPU core loads, it starts executing the schedular which is a non terminating program, running an infinite
loop. The scheduler picks a waiting process from a process table and switches control to it. This switching is known
appropriately as context switching.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/proc.c#L444-L481" >}}

In essence, `scheduler` looks through the process table for a process in the `RUNNABLE` state, updates its state to
`RUNNING` and then calls `swtch`. Calling `swtch` starts running that process and when the process is done running, it
switches back to `scheduler`. This switching is appropriately called context switching. The `swtch` method swaps the
context of the core with that of the process. The context being a set of registers.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/proc.h#L2-L19" >}}

The `ra` register holds the address from which the cpu resumes executation and `sp` points to the stack so that the
process resumes with the same stack values it had when it was paused.

## Pre-emptive Multitasking

Some CPU bound processes take long to compute and have to be asked to kindly leave the CPU for other processes to run.
This is how pre-emptive scheduling works and the mechanism is made possible by **timer interrupts**. Timer interrupts
are generated by a timer hardware.

When a timer interrupt happens control jumps to `usertrap` where `yield` is called if we are handling a timer interrupt.
{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/trap.c#L79-L81" >}}

Yield acquires a lock over the process then update the process' state to `RUNNABLE` which means another cpu core can run
it once the lock is released. Before releasing the process lock, `sched` is invoked.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/proc.c#L510-L519" >}}

`sched` doesn't do much, other than calling `swtch`. This time restoring the registers in the **cpu context** where the
return address is the address after the call to `swtch` in `schedule`. That is to say, `yield` gives back control to
`schedule` so that it can find another process and run it.

{{< gh "https://github.com/mit-pdos/xv6-riscv/blob/de247db5e6384b138f270e0a7c745989b5a9c23b/kernel/proc.c#L490-L508" >}}
